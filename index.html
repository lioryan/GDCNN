function handleMouseMove(e) {
            if (!state.isDragging && !state.isRotating && !state.isPanning) return;

            const deltaX = e.clientX - state.lastMousePos.x;
            const deltaY = e.clientY - state.lastMousePos.y;
            
            if (state.isRotating) {
                state.rotation.y = (state.rotation.y + deltaX * 0.5) % 360;
                state.rotation.x = Math.max(-90, Math.min(90, state.rotation.x + deltaY * 0.5));
            } else if (state.isPanning) {
                state.translation.x += deltaX;
                state.translation.y += deltaY;
            } else if (state.isDragging) {
                state.currentPos.x = Math.max(-5, Math.min(5, state.currentPos.x + deltaX * 0.01));
                state.currentPos.y = Math.max(-5, Math.min(5, state.currentPos.y - deltaY * 0.01));
                updateSliders();
            }
            
            state.lastMousePos = { x: e.clientX, y: e.clientY };
            draw();
        }

        function handleMouseUp() {
            state.isDragging = false;
            state.isRotating = false;
            state.isPanning = false;
        }

        function handleWheel(e) {
            e.preventDefault();
            const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
            state.scale = Math.max(0.1, Math.min(5, state.scale * scaleFactor));
            draw();
        }

        // Touch event handlers for mobile support
        function handleTouchStart(e) {
            if (e.touches.length === 1) {
                state.isDragging = true;
                state.lastMousePos = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
            } else if (e.touches.length === 2) {
                // Store initial touch points for pinch-zoom
                state.initialTouchDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
            }
            e.preventDefault();
        }

        function handleTouchMove(e) {
            if (e.touches.length === 1 && state.isDragging) {
                const deltaX = e.touches[0].clientX - state.lastMousePos.x;
                const deltaY = e.touches[0].clientY - state.lastMousePos.y;
                
                state.currentPos.x = Math.max(-5, Math.min(5, state.currentPos.x + deltaX * 0.01));
                state.currentPos.y = Math.max(-5, Math.min(5, state.currentPos.y - deltaY * 0.01));
                
                state.lastMousePos = { 
                    x: e.touches[0].clientX, 
                    y: e.touches[0].clientY 
                };
                updateSliders();
                draw();
            } else if (e.touches.length === 2) {
                // Handle pinch-zoom
                const currentDistance = Math.hypot(
                    e.touches[0].clientX - e.touches[1].clientX,
                    e.touches[0].clientY - e.touches[1].clientY
                );
                
                if (state.initialTouchDistance) {
                    const scaleFactor = currentDistance / state.initialTouchDistance;
                    state.scale = Math.max(0.1, Math.min(5, state.scale * scaleFactor));
                    state.initialTouchDistance = currentDistance;
                    draw();
                }
            }
            e.preventDefault();
        }

        function handleTouchEnd() {
            state.isDragging = false;
            state.initialTouchDistance = null;
        }

        function updateSliders() {
            safeExecute(() => {
                const xSlider = document.getElementById('x');
                const ySlider = document.getElementById('y');
                
                if (xSlider && ySlider) {
                    xSlider.value = state.currentPos.x;
                    ySlider.value = state.currentPos.y;
                    
                    document.getElementById('x-value').textContent = state.currentPos.x.toFixed(1);
                    document.getElementById('y-value').textContent = state.currentPos.y.toFixed(1);
                    document.getElementById('value').textContent = 
                        `Loss: ${loss(state.currentPos.x, state.currentPos.y, state.morphValue).toFixed(1)}`;
                }
            });
        }

        // Event Listeners
        function initializeEventListeners() {
            // Mouse events
            surfaceCanvas.addEventListener('mousedown', handleMouseDown);
            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
            surfaceCanvas.addEventListener('wheel', handleWheel);
            surfaceCanvas.addEventListener('contextmenu', e => e.preventDefault());

            // Touch events
            surfaceCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            surfaceCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            surfaceCanvas.addEventListener('touchend', handleTouchEnd);

            // Slider events
            const xSlider = document.getElementById('x');
            const ySlider = document.getElementById('y');
            const morphSlider = document.getElementById('morph');

            if (xSlider) {
                xSlider.addEventListener('input', (e) => {
                    state.currentPos.x = parseFloat(e.target.value);
                    updateSliders();
                    draw();
                });
            }

            if (ySlider) {
                ySlider.addEventListener('input', (e) => {
                    state.currentPos.y = parseFloat(e.target.value);
                    updateSliders();
                    draw();
                });
            }

            if (morphSlider) {
                morphSlider.addEventListener('input', (e) => {
                    state.morphValue = parseFloat(e.target.value);
                    document.getElementById('morph-value').textContent = 
                        state.morphValue === 0 ? 'Flat' : state.morphValue === 1 ? 'Bowl' : 'Morphing';
                    draw();
                });
            }

            // Window resize
            window.addEventListener('resize', debounce(resizeCanvases, 250));
        }

        // Initialize
        function initialize() {
            resizeCanvases();
            updateSliders();
            initializeEventListeners();
        }

        // Start the application
        initialize();
    </script>
</body>
</html>
