<!DOCTYPE html>
<html>
<head>
    <title>Neural Network Unit with Morphing Surface</title>
    <style>
        body{margin:0;padding:0;font-family:Arial,sans-serif;background:#fff;overflow:hidden}
        .container{display:grid;grid-template-columns:60% 40%;width:100vw;height:100vh}
        #bowl-container{position:relative;touch-action:none}
        #network-container{position:relative;background:#f8f9fa;border-left:1px solid #ddd;padding:20px}
        .controls,.instructions,#mse-equation{position:fixed;background:rgba(255,255,255,.95);padding:15px;border-radius:8px;box-shadow:0 0 10px rgba(0,0,0,.1);z-index:1000}
        .controls{top:20px;left:20px;max-width:300px}
        #mse-equation{top:20px;right:45%;font-family:"Times New Roman",serif;font-size:1.2em;max-width:400px;word-wrap:break-word}
        .instructions{bottom:20px;left:20px;max-width:300px}
        .slider-group{margin-bottom:15px}
        .slider-group label{display:block;margin-bottom:5px}
        input[type="range"]{width:100%;max-width:200px}
        .shape-control{margin-top:20px;padding-top:15px;border-top:1px solid #ddd}
        canvas{display:block;touch-action:none}
        @media(max-width:768px){.container{grid-template-columns:1fr}#mse-equation{right:20px;font-size:1em}}
    </style>
</head>
<body>
    <div class="container">
        <div id="bowl-container"><canvas id="surface-canvas"></canvas></div>
        <div id="network-container"><canvas id="network-canvas"></canvas></div>
    </div>
    <div id="mse-equation">MSE = ½(y - ŷ)² = ½(0 - (θ₁x₁ + θ₂x₂))² = 0.0</div>
    <div class="controls">
        <div class="slider-group">
            <label>Weight 1 (θ₁): <span id="x-value">0.0</span></label>
            <input type="range" id="x" min="-5" max="5" value="0" step="0.1">
        </div>
        <div class="slider-group">
            <label>Weight 2 (θ₂): <span id="y-value">0.0</span></label>
            <input type="range" id="y" min="-5" max="5" value="0" step="0.1">
        </div>
        <div class="shape-control">
            <label>Surface Shape: <span id="morph-value">Flat</span></label>
            <input type="range" id="morph" min="0" max="1" value="0" step="0.01">
        </div>
        <div id="value">Loss: 0.0</div>
    </div>
    <div class="instructions">
        • Drag red point to adjust weights<br>
        • Right-click + drag to rotate view<br>
        • Mouse wheel to zoom<br>
        • Middle-click + drag to move graph<br>
        • Use shape slider to morph surface
    </div>

<script>
const s={width:0,height:0,rot:{x:45,y:45},scale:1,morph:0,pos:{x:0,y:0},trans:{x:0,y:0},isDrag:false,isRot:false,isPan:false,last:{x:0,y:0},frame:null},
      c={surf:document.getElementById('surface-canvas'),net:document.getElementById('network-canvas')},
      ctx={surf:c.surf.getContext('2d'),net:c.net.getContext('2d')};

const run=(f,d=null)=>{ try{return f()}catch(e){console.error(e);return d} };
const loss=(x,y,m)=>run(()=>(x*x+y*y)*m,0);

const proj=(x,y,z)=>run(()=>{
    const sc=Math.min(s.width,s.height)/12*s.scale,
          [cx,cy]=[s.width/2+s.trans.x,s.height/2+s.trans.y],
          [xr,yr]=[s.rot.x*Math.PI/180,s.rot.y*Math.PI/180],
          y1=y*Math.cos(xr)-z*Math.sin(xr),
          z1=y*Math.sin(xr)+z*Math.cos(xr),
          x2=x*Math.cos(yr)+z1*Math.sin(yr);
    return {x:x2*sc+cx,y:y1*sc+cy};
},{x:s.width/2,y:s.height/2});

const draw=()=>{
    if(s.frame)cancelAnimationFrame(s.frame);
    s.frame=requestAnimationFrame(()=>{
        // Surface
        ctx.surf.clearRect(0,0,s.width,s.height);
        for(let x=-5;x<=5;x+=.2)for(let y=-5;y<=5;y+=.2){
            const z=loss(x,y,s.morph),p=proj(x,y,z),
                  h=Math.min(z/50,1),c=`hsl(${240-h*180},80%,50%)`;
            ctx.surf.beginPath();
            ctx.surf.arc(p.x,p.y,2*s.scale,0,2*Math.PI);
            ctx.surf.fillStyle=c;
            ctx.surf.fill();
        }
        
        const z=loss(s.pos.x,s.pos.y,s.morph),
              p=proj(s.pos.x,s.pos.y,z),
              b=proj(s.pos.x,s.pos.y,0);
        
        ctx.surf.beginPath();
        ctx.surf.moveTo(p.x,p.y);
        ctx.surf.lineTo(p.x,b.y);
        ctx.surf.strokeStyle='rgba(0,0,0,.5)';
        ctx.surf.setLineDash([5,5]);
        ctx.surf.stroke();
        ctx.surf.setLineDash([]);
        
        ctx.surf.beginPath();
        ctx.surf.arc(p.x,p.y,6*s.scale,0,2*Math.PI);
        ctx.surf.fillStyle='red';
        ctx.surf.fill();

        // Network
        const [w,h]=[c.net.width,c.net.height];
        ctx.net.clearRect(0,0,w,h);
        
        const r=20,[y1,y2,yo]=[h*.3,h*.7,h*.5],
              [x1,x2,xo]=[w*.2,w*.2,w*.8];
        
        const drawNeuron=(x,y,l)=>{
            ctx.net.beginPath();
            ctx.net.arc(x,y,r,0,2*Math.PI);
            ctx.net.fillStyle='#fff';
            ctx.net.fill();
            ctx.net.strokeStyle='#000';
            ctx.net.lineWidth=2;
            ctx.net.stroke();
            ctx.net.fillStyle='#000';
            ctx.net.font='16px Arial';
            ctx.net.textAlign='center';
            ctx.net.textBaseline='middle';
            ctx.net.fillText(l,x,y);
        };

        const drawConn=(x1,y1,x2,y2,w)=>{
            ctx.net.beginPath();
            ctx.net.moveTo(x1,y1);
            ctx.net.lineTo(x2,y2);
            ctx.net.strokeStyle=w>=0?'blue':'red';
            ctx.net.lineWidth=Math.abs(w)*2;
            ctx.net.stroke();
            ctx.net.fillStyle='#000';
            ctx.net.font='14px Arial';
            ctx.net.fillText(w.toFixed(2),(x1+x2)/2,(y1+y2)/2);
        };

        drawConn(x1+r,y1,xo-r,yo,s.pos.x);
        drawConn(x2+r,y2,xo-r,yo,s.pos.y);
        drawNeuron(x1,y1,"x₁");
        drawNeuron(x2,y2,"x₂");
        drawNeuron(xo,yo,"y");
        
        ctx.net.font='bold 18px Arial';
        ctx.net.fillStyle='#000';
        ctx.net.textAlign='center';
        ctx.net.fillText('Neural Network Unit',w/2,30);

        // Update MSE
        const pred=s.pos.x+s.pos.y,
              mse=0.5*pred*pred;
        document.getElementById('mse-equation').innerHTML=
            `MSE = ½(y - ŷ)² = ½(0 - (θ₁x₁ + θ₂x₂))² = ½(0 - (${s.pos.x.toFixed(1)} × 1 + ${s.pos.y.toFixed(1)} × 1))² = ${mse.toFixed(2)}`;
    });
};

const updateSliders=()=>run(()=>{
    const[x,y]=[document.getElementById('x'),document.getElementById('y')];
    if(x&&y){
        x.value=s.pos.x;
        y.value=s.pos.y;
        document.getElementById('x-value').textContent=s.pos.x.toFixed(1);
        document.getElementById('y-value').textContent=s.pos.y.toFixed(1);
        document.getElementById('value').textContent=`Loss: ${loss(s.pos.x,s.pos.y,s.morph).toFixed(1)}`;
    }
});

const resize=()=>run(()=>{
    const dpr=window.devicePixelRatio||1,
          [bc,nc]=[document.getElementById('bowl-container'),document.getElementById('network-container')];
    if(!bc||!nc)return;
    
    s.width=bc.clientWidth;
    s.height=bc.clientHeight;
    [c.surf.width,c.surf.height]=[s.width*dpr,s.height*dpr];
    [c.surf.style.width,c.surf.style.height]=[`${s.width}px`,`${s.height}px`];
    ctx.surf.scale(dpr,dpr);
    
    const [w,h]=[nc.clientWidth,nc.clientHeight];
    [c.net.width,c.net.height]=[w*dpr,h*dpr];
    [c.net.style.width,c.net.style.height]=[`${w}px`,`${h}px`];
    ctx.net.scale(dpr,dpr);
    
    requestAnimationFrame(draw);
});

// Event Handlers
const events={
    mouse:{
        down:e=>{
            s.last={x:e.clientX,y:e.clientY};
            if(e.button===2)s.isRot=true;
            else if(e.button===1){s.isPan=true;e.preventDefault();}
            else s.isDrag=true;
        },
        move:e=>{
            if(!s.isDrag&&!s.isRot&&!s.isPan)return;
            const[dx,dy]=[e.clientX-s.last.x,e.clientY-s.last.y];
            if(s.isRot){
                s.rot.y=(s.rot.y+dx*.5)%360;
                s.rot.x=Math.max(-90,Math.min(90,s.rot.x+dy*.5));
            }else if(s.isPan){
                s.trans.x+=dx;
                s.trans.y+=dy;
            }else if(s.isDrag){
                s.pos.x=Math.max(-5,Math.min(5,s.pos.x+dx*.01));
                s.pos.y=Math.max(-5,Math.min(5,s.pos.y-dy*.01));
                updateSliders();
            }
            s.last={x:e.clientX,y:e.clientY};
            draw();
        },
        up:()=>{s.isDrag=s.isRot=s.isPan=false;},
        wheel:e=>{
            e.preventDefault();
            s.scale=Math.max(.1,Math.min(5,s.scale*(e.deltaY>0?.9:1.1)));
            draw();
        }
    },
    touch:{
        start:e=>{
            if(e.touches.length===1){
                s.isDrag=true;
                s.last={x:e.touches[0].clientX,y:e.touches[0].clientY};
            }else if(e.touches.length===2)
                s.initDist=Math.hypot(
                    e.touches[0].clientX-e.touches[1].clientX,
                    e.touches[0].clientY-e.touches[1].clientY
                );
            e.preventDefault();
        },
        move:e=>{
            if(e.touches.length===1&&s.isDrag){
                const[dx,dy]=[e.touches[0].clientX-s.last.x,e.touches[0].clientY-s.last.y];
                s.pos.x=Math.max(-5,Math.min(5,s.pos.x+dx*.01));
                s.pos.y=Math.max(-5,Math.min(5,s.pos.y-dy*.01));
                s.last={x:e.touches[0].clientX,y:e.touches[0].clientY};
                updateSliders();
                draw();
            }else if(e.touches.length===2&&s.initDist){
                const d=Math.hypot(
                    e.touches[0].clientX-e.touches[1].clientX,
                    e.touches[0].clientY-e.touches[1].clientY
                );
                s.scale=Math.max(.1,Math.min(5,s.scale*d/s.initDist));
                s.initDist=d;
                draw();
            }
            e.preventDefault();
        },
        end:()=>{s.isDrag=false;s.initDist=null;}
    }
};

// Initialize
(()=>{
    c.surf.addEventListener('mousedown',events.mouse.down);
    window.addEventListener('mousemove',events.mouse.move);
    window.addEventListener('mouseup',events.mouse.up);
    c.surf.addEventListener('wheel',events.mouse.wheel);
    c.surf.addEventListener('contextmenu',e=>e.preventDefault());
    c.surf.addEventListener('touchstart',events.touch.start,{passive:false});
    c.surf.addEventListener('touchmove',events.touch.move,{passive:false});
    c.surf.addEventListener('touchend',events.touch.end);

    ['x','y','morph'].forEach(id=>{
        const el=document.getElementById(id);
        if(el)el.addEventListener('input',e=>{
            if(id==='morph'){
                if(id==='morph'){
                s.morph=parseFloat(e.target.value);
                document.getElementById('morph-value').textContent=
                    s.morph===0?'Flat':s.morph===1?'Bowl':'Morphing';
            }else{
                s.pos[id]=parseFloat(e.target.value);
                updateSliders();
            }
            draw();
        });
    });

    let resizeTimer;
    window.addEventListener('resize',()=>{
        clearTimeout(resizeTimer);
        resizeTimer=setTimeout(resize,250);
    });

    resize();
    updateSliders();
})();
</script>
</body>
</html>
